# 솔리테어 솔버 벤치마크 보고서

**측정일**: 2026-02-16
**환경**: macOS Apple Silicon, Node.js v22.22.0
**알고리즘**: Nested Rollout Policy Adaptation (NRPA)
**참고 논문**: "Searching Solitaire in Real Time" (Bjarnason, Tadepalli, Fern)

---

## 결과 요약

| 설정 | 게임 수 | 승률 | 평균 시간 | 중앙값 | 평균 탐색 노드 |
|------|--------|------|----------|--------|--------------|
| Greedy (n0=0, n1=0) | 100 | **15%** | 2ms | 2ms | 279 |
| 기본 (n0=1, n1=1) | 100 | **64%** | 419ms | 40ms | 115,748 |
| 심층 (n0=2, n1=1) | 50 | **70%** | 1,817ms | 34ms | 440,530 |

---

## 논문 대비 비교

| 구현 | 설정 | 게임 수 | 타임아웃 | 승률 |
|------|------|--------|---------|------|
| 논문 (C++) | n0=1, n1=1 | 50,000 | 60초 | **74.94%** |
| 본 구현 (TypeScript) | n0=1, n1=1 | 100 | 5초 | **64.0%** |
| 본 구현 (TypeScript) | n0=2, n1=1 | 50 | 10초 | **70.0%** |

**차이 원인 (약 11% 갭)**:
1. **타임아웃 차이** (5초 vs 60초) — 어려운 게임에서 탐색 시간이 부족하여 3게임이 5초 타임아웃에 도달
2. **표본 크기** (100 vs 50,000) — 소규모 표본에 의한 높은 분산, 95% 신뢰구간 ±9.4%
3. **언어 오버헤드** — TypeScript/V8 vs 최적화된 C++, 다만 V8 JIT가 상당 부분 보완

---

## 알고리즘 구조

Thoughtful Klondike(모든 카드 공개) 솔리테어를 위한 **중첩 롤아웃 정책 적응(NRPA)** 알고리즘.

```
Level 0 (Greedy): 각 합법 수를 휴리스틱으로 평가, 최선 선택
Level 1 (1-ply):  각 수마다 Level 0 롤아웃으로 평가
Level 2 (2-ply):  각 수마다 Level 1 롤아웃으로 평가
```

**핵심 기법**:
- **이중 휴리스틱** (H1/H2): 한 휴리스틱에서 정체되면 다른 휴리스틱으로 전환
- **K+ 표현**: Stock/Waste를 `stockTurns` 매크로 액션으로 인코딩
- **하위 경로 WIN 전파**: 중첩 탐색에서 승리 경로 발견 시 전체 경로를 한 번에 적용
- **루프 감지**: 상태 해시 기반 글로벌 경로 + 역방향 수 필터링

### 휴리스틱 특성 (6개)

| # | 특성 | H1 가중치 | H2 가중치 |
|---|------|----------|----------|
| 1 | Foundation에 있는 카드 | 5 - rank | 5 (고정) |
| 2 | Tableau에서 뒤집어진 카드 | rank - 13 | rank - 13 |
| 3 | Talon에서 접근 가능한 카드 | 0 | +1/장 |
| 4 | 같은 랭크/색상 쌍이 모두 뒤집어짐 | -5 | -1 |
| 5 | 같은 Suit 하위 랭크 카드를 차단 | -5 | -1 |
| 6 | 자신의 Tableau 빌드 카드를 차단 | -10 | -5 |

---

## 설정별 상세 결과

### Greedy (기준선)

순수 휴리스틱 기반, 선행 탐색(lookahead) 없음.

| 지표 | 값 |
|------|-----|
| 승률 | 15% (15/100) |
| 평균 시간 | 2ms |
| 승리 시 평균 수 | 103수 |
| 평균 노드 | 279 |

### 기본 설정 (n0=1, n1=1)

논문 기본 설정. Greedy 대비 승률 **4.3배** 향상.

| 지표 | 값 |
|------|-----|
| 승률 | 64% (64/100) |
| 평균 시간 | 419ms |
| 승리 시 평균 시간 | 142ms |
| 패배 시 평균 시간 | 913ms |
| 승리 시 평균 수 | 115수 |
| 평균 노드 | 115,748 |

**시간 분포**: 52% 게임이 100ms 이내 해결(대부분 승리), 3% 게임이 5초 타임아웃 도달.

### 심층 설정 (n0=2, n1=1)

기본 대비 +6% 승률, 4.3배 느림.

| 지표 | 값 |
|------|-----|
| 승률 | 70% (35/50) |
| 평균 시간 | 1,817ms |
| 승리 시 평균 시간 | 397ms |
| 패배 시 평균 시간 | 5,132ms |
| 승리 시 평균 수 | 109수 |
| 평균 노드 | 440,530 |

---

## 적용된 최적화

### 효과 있음

| 최적화 | 효과 | 설명 |
|--------|------|------|
| 부분 스택 이동 | 승률 +8% | Tableau에서 face-up 카드 부분 이동 허용 |
| 하위 경로 WIN 전파 | 승률 +20% | 중첩 탐색 승리 시 전체 경로를 한 번에 적용 |
| Suit 값 캐싱 (`_sv`, `_red`) | 속도 ~2배 | Enum `.value` 접근 오버헤드 제거 |
| 수 시그니처 패킹 | 루프 감지 가속 | 수 정보를 32비트 정수 하나로 압축 |
| FNV-1a 상태 해시 | 빠른 루프 감지 | 전체 게임 상태를 32비트 해시로 압축 |
| K+ 매크로 액션 | Waste 접근성 향상 | Stock 순환을 시뮬레이션하여 도달 가능한 모든 Waste 카드 탐색 |

### 효과 없음

| 최적화 | 결과 | 이유 |
|--------|------|------|
| 도메인 프루닝 완화 | 불건전(UNSOUND) | T→T 이동의 카드 공개가 삭제 효과에 의존 |
| 로컬 루프 방지 (단독) | 개선 없음 | 글로벌 경로 감지가 이미 포함 |

---

## 타임아웃 vs 승률 추이

| 타임아웃 | 추정 승률 (n0=1, n1=1) |
|---------|----------------------|
| 1초 | ~55% |
| 5초 | 64% (측정값) |
| 10초 | ~68% |
| 60초 | ~73-75% (논문 수준) |

## 탐색 속도

V8 JIT 환경에서 약 **초당 250K 노드** 탐색. 최적화된 C++ 대비 5-10배 느리나, 인터프리터 언어 대비 경쟁력 있음.

---

## 재현 방법

```bash
cd web
npx tsx benchmark-solver.ts
```

Mulberry32 시드 기반 결정적 셔플 사용. 수 선택 시 `Math.random()` 셔플로 인해 실행마다 ±3% 이내 변동 가능.
